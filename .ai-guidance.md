Passo 1:
Definir escopo MVP por desafio — listar claramente o que será implementado e priorizar (Obrigatório vs Opcional).
- Desafio 1: Endpoints CRUD de Pacientes, CRUD de Histórico Médico, autenticação JWT, endpoint para exames externos (mock ou BrasilAPI).
- Desafio 2: Diagrama de integração FinX → HIS, interface IFileStorage e contrato de transferência. (Localização: `src/Finx.Integrations/` e `docs/` — ver detalhes abaixo.)
- Desafio 3: Script SQL idempotente para unificação de pacientes (regra principal abaixo).

Passo 2:
Criar a solução e estrutura de pastas (monorepo) — os projetos de teste devem ficar dentro de `src/` ao lado dos demais projetos:
- `Finx.Solution.sln`
- `src/Finx.Api/` (API)
- `src/Finx.Domain/` (modelos, serviços)
- `src/Finx.Infrastructure/` (EF Core, repositórios, clients)
- `src/Finx.Integrations/` (Desafio 2: diagramas, adaptadores opcionais, contratos de integração e exemplos de payloads)
- `src/Finx.Scripts/` (scripts SQL)
- `src/Finx.Api.Tests/` (testes unitários e integração relacionados à API)
- `docs/` (diagramas, postman_collection.json)
- `docker/` (Dockerfiles e `docker-compose.yml` para subir rapidamente a stack)

# Detalhes do Desafio 2 (localização e conteúdo esperados)
O Desafio 2 ficará implementado principalmente em duas localizações do repositório:
- `src/Finx.Integrations/` — código opcional de adaptadores e interfaces (por exemplo, `IFileStorage`, adaptador para HIS simulado, exemplos de cliente HTTP/SFTP se aplicável). Estrutura sugerida:
  - `src/Finx.Integrations/Adapters/` — implementações de exemplo para envio de arquivos ao HIS (simulado).
  - `src/Finx.Integrations/Contracts/` — interfaces e DTOs de contrato entre FinX e HIS.
  - `src/Finx.Integrations/Tests/` — testes específicos de integração de adaptadores (opcional).

- `docs/` — documentação e diagramas formais do fluxo (arquivo `desafio-2-diagrama.svg` ou `desafio-2-diagrama.drawio`) e instruções de configuração para o avaliador. Incluir também exemplos de payloads, formatos esperados e observações sobre segurança/transmissão (TLS, autenticação do HIS, mapeamento de IDs entre FinX e HIS).

Passo 3:
Modelagem de domínio inicial (mínimo necessário):
- `Paciente`: Id (PK), Nome, Cpf, DataNascimento, DataCadastro, Contato.
- `HistoricoMedico`: Id, PacienteId (FK), Diagnostico, Exame, Prescricao, Data.
- `Hospital`: Id, Nome, Cnpj, Grupo.
- `PacienteHospital`: PacienteId, HospitalId, Codigo (código único por hospital).
- `Agendamento`: Id, HospitalId, PacienteId, Data.
Adicionar índices em `Cpf` e em `(HospitalId, Codigo)`.

Passo 4:
Definir contratos de API (exemplos mínimos):
- POST `/api/auth/login` -> retorna JWT (201).
- GET `/api/pacientes`, GET `/api/pacientes/{id}`, POST `/api/pacientes`, PUT `/api/pacientes/{id}`, DELETE `/api/pacientes/{id}`.
- GET/POST/PUT/DELETE `/api/pacientes/{id}/historico`.
- GET `/api/exames/{cpf}` -> consulta mock/externa.
Documentar DTOs e códigos de resposta (200/201/400/401/404).

Passo 5:
Segurança:
- JWT com claims mínimos (`sub`, `roles`), roles `User` e `Admin`.
- Algoritmo HS256, expirações curtas em produção.
- Não commitar segredos; usar `dotnet user-secrets` ou variáveis de ambiente.
- Validar autorização por endpoint (políticas simples).

Passo 6:
Arquitetura e camadas — usar MediatR/CQRS para separar responsabilidade e evitar lógica/repositórios nas controllers:
- Controllers finos que delegam comandos/queries via MediatR (`IMediator`).
- Handlers (CommandHandler / QueryHandler) implementam a lógica de aplicação e interagem com repositórios/serviços da camada de infraestrutura.
- Repositórios e DbContext permanecem na camada de infraestrutura, mas não são usados diretamente nas controllers.
- Mappers para DTO ↔ Entity.
- Injeção de dependência via construtor (DI container padrão do ASP.NET Core).

Obs: se houver cenários complexos de leitura/escrita, aplicar CQRS (separar modelos de leitura com projeções/DTOs) — caso contrário usar MediatR apenas para organizar comandos e queries.

Passo 7:
Persistência:
- EF Core com migrations.
- Repositórios assíncronos (infra) e handlers assíncronos (`async/await`).
- Paginação, projeções (Select → DTO) para listas.
- Evitar carregamento desnecessário (use .Select, .AsNoTracking quando apropriado).

Passo 8:
Integrações externas:
- Criar `IExameClient` com implementação real (HttpClient) e mock/fallback.
- Criar `IFileStorage` (Azure Blob) com operações `UploadAsync`, `GetAsync`, `DeleteAsync`; no BD armazenar apenas o ID do arquivo.

Passo 9:
Regra de unificação (Desafio 3) — regra explícita:
- Identificar duplicatas por CPF ou por Código do paciente no hospital.
- Manter o registro com `DataCadastro` mais recente (sobrevivente).
- Atualizar `PacienteHospital` e `Agendamento` para referenciar o paciente sobrevivente.
- Implementar em script SQL idempotente e em migration EF opcional.
- Executar em transação com checagens de integridade.

Passo 10:
Testes — localização e práticas:
- Projetos de testes devem ficar dentro de `src/` (por exemplo `src/Finx.Api.Tests/`) para facilitar descoberta pelo avaliador.
- Unitários: validação CPF, regras de negócio, serviços e handlers.
- Integração: endpoints principais (criação/consulta) usando InMemory/SQLite ou contêiner.
- Teste de integração que valide fluxo de autenticação + criação de paciente.
- Cobertura focal: regras críticas (unificação, segurança, persistência).

Passo 11:
Observabilidade e resiliência:
- Health checks (endpoints de readiness/liveness).
- Logs estruturados (Serilog).
- Políticas de retry/circuit-breaker para chamadas externas (Polly).
- Timeouts razoáveis em HttpClient.

Passo 12:
Docker e orquestração:
- Incluir `Dockerfile` para a API e um `docker-compose.yml` em `docker/` que levante: API, banco de dados (ex.: Postgres ou SQL Server container), e opcionalmente Redis para cache.
- Documentar comandos para build e execução com Docker: `docker-compose up --build`.
- Garantir que a solução possa ser executada localmente por avaliadores via Docker sem configurações locais complexas.

Passo 13:
Performance e escalabilidade:
- Paginação e filtros por servidor (DB).
- Índices apropriados: `Cpf`, `(HospitalId, Codigo)`.
- Cache de leitura (Redis) para endpoints de alta demanda (opcional).
- Considerar CQRS/Read-Replica em escala maior.

Passo 14:
Qualidade de código e estilo:
- Seguir SOLID e Clean Code.
- File-scoped namespaces permitidos; 4 espaços de indentação.
- Usar `/.editorconfig` e executar `dotnet format` antes de commitar.
- Nomes PascalCase para tipos públicos; campos privados `_camelCase`.

Passo 15:
Checklist pré-commit / pré-submissão:
- `dotnet build` -> OK.
- `dotnet test` -> OK.
- `dotnet format` aplicado.
- Sem segredos no repositório.
- README atualizado com instruções e mapeamento dos desafios.
- `postman_collection.json` em `docs/` (recomendado).

Passo 16:
Prompts operacionais (modelos para requisições atômicas à IA):
- “Implemente o `PacientesController` que publica Commands/Queries via MediatR; gere DTOs, validações e testes unitários para o handler de criação `CreatePacienteCommandHandler` validando CPF.”
- “Gere um script SQL idempotente que una pacientes duplicados mantendo o registro com maior `DataCadastro` e atualize `PacienteHospital` e `Agendamento`.”
- “Implemente `IExameClient` que consulta um endpoint externo e retorne lista de exames; crie fallback mock.”

Passo 17:
Observações finais:
- Manter este arquivo como guia interno; não incluir segredos.
- Adicionar `ai-guidance.md` ao `.gitignore` local se desejar manter privado.

---
Use este arquivo como checklist e fonte de verdade para implementações atômicas.